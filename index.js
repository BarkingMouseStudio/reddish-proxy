// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, G, R, X, Y, key, key_regex, local, local_hostname, local_port, local_protocol_regex, net, optimist, options, protocol, redis, remote, remote_connection, remote_hostname, remote_monitor_connection, secure, tls, url, verbose, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  process.title = 'reddish-proxy';

  url = require('url');

  net = require('net');

  redis = require('redis');

  optimist = require('optimist');

  tls = require('tls');

  options = optimist.usage("Usage: " + process.title + " --local [local] --remote [remote] --key [key] -p1 [port] -p2 [port]").demand(['local', 'remote', 'key'])["default"]('local', 'redis://127.0.0.1:6379')["default"]('remote', 'http://127.0.0.1')["default"]('remote_port', 8000)["default"]('remote_monitor_port', 8001)["default"]('secure', false)["default"]('verbose', false).boolean('secure').boolean('verbose').describe('help', 'Print this help text.').describe('key', 'Your Reddish connection key from your reddish instance.').describe('local', 'The redis:// url to your local redis server.').describe('remote', 'The url to your remote reddish instance socket.').describe('remote_port', 'The standard port to your remote reddish instance socket.').describe('remote_monitor_port', 'The monitor port to your remote reddish instance socket.').describe('secure', 'Should TLS/SSL be used (your reddish server will need to be configured with certs).').describe('verbose', 'Turn on extra logging.').alias('local', 'l').alias('remote', 'r').alias('remote_port', 'p1').alias('remote_monitor_port', 'p2').alias('key', 'k').alias('secure', 's').alias('verbose', 'v').argv;

  key = options.key, local = options.local, remote = options.remote, verbose = options.verbose, secure = options.secure;

  R = "\x1b[31m";

  G = "\x1b[32m";

  Y = "\x1b[33m";

  X = "\x1b[39m";

  key_regex = /^[a-f0-9]{40}$/i;

  if (!key_regex.test(key)) {
    console.error("" + R + "ERROR" + X, 'Invalid connection key', key);
    return;
  }

  _ref = url.parse(local), protocol = _ref.protocol, local_port = _ref.port, local_hostname = _ref.hostname;

  local_protocol_regex = /^redis/i;

  if (!local_protocol_regex.test(protocol)) {
    console.error("" + R + "ERROR" + X, 'Invalid redis protocol', protocol);
    return;
  }

  options.local_hostname = local_hostname;

  options.local_port = local_port;

  remote_hostname = url.parse(remote).hostname;

  options.remote_hostname = remote_hostname;

  Connection = (function() {

    Connection.verbose = verbose;

    Connection.secure = secure;

    Connection.prototype.handshaken = false;

    Connection.prototype.connected = false;

    Connection.prototype.handleLocalConnect = function() {
      if (Connection.verbose) {
        return console.log("Local redis client connected", "" + this.local_hostname + ":" + this.local_port);
      }
    };

    Connection.prototype.handleLocalData = function(data) {
      if (this.remote_endpoint && this.handshaken) {
        return this.remote_endpoint.write(data);
      }
    };

    Connection.prototype.handleLocalClose = function(err) {
      console.error("" + R + "ERROR" + X, 'Local client closed', "" + this.local_hostname + ":" + this.local_port);
      if (this.connected) {
        console.error("" + R + "ERROR" + X, 'Reconnecting Local client', "" + this.local_hostname + ":" + this.local_port);
        return this.local_client.connect(this.local_port, this.local_hostname);
      }
    };

    Connection.prototype.handleLocalError = function(err) {
      if (err) {
        return console.error("" + R + "ERROR" + X, 'Local client error', err.message);
      }
    };

    Connection.prototype.initializeLocalConnection = function(options) {
      if (Connection.verbose) {
        console.log('Local redis client connecting...', "" + this.local_hostname + ":" + this.local_port);
      }
      this.local_client = net.createConnection(this.local_port, this.local_hostname);
      this.local_client.setTimeout(0);
      this.local_client.setNoDelay();
      this.local_client.setKeepAlive(true);
      this.local_client.on('connect', this.handleLocalConnect);
      this.local_client.on('data', this.handleLocalData);
      this.local_client.on('close', this.handleLocalClose);
      return this.local_client.on('error', this.handleLocalError);
    };

    Connection.prototype.handleRemoteConnect = function() {
      var data;
      this.connected = true;
      if (!this.handshaken) {
        if (Connection.verbose) {
          console.log("Handshaking with endpoint at " + this.remote_hostname + ":" + this.remote_port + "...");
        }
        return this.remote_endpoint.write(data = JSON.stringify({
          key: this.key
        }));
      }
    };

    Connection.prototype.handleRemoteHandshake = function(data) {
      var err, json;
      try {
        json = JSON.parse(data.toString());
        if (err = json != null ? json.error : void 0) {
          console.error("" + R + "ERROR" + X, 'Endpoint handshake failed:', err);
          return;
        }
        console.log("" + G + "SUCCESS" + X, "Proxying redis client at " + this.local_hostname + ":" + this.local_port + " to reddish endpoint at " + this.remote_hostname + ":" + this.remote_port + "...");
        return this.handshaken = true;
      } catch (err) {
        return console.error("" + R + "ERROR" + X, 'Endpoint handshake failed:', err);
      }
    };

    Connection.prototype.handleRemoteData = function(data) {
      if (!this.handshaken) {
        return this.handleRemoteHandshake(data);
      }
      return this.local_client.write(data);
    };

    Connection.prototype.handleRemoteClose = function(err) {
      this.connected = false;
      console.error("" + R + "ERROR" + X, 'Remote endpoint closed, closing Local client', (err ? err.message : void 0));
      return this.local_client.end();
    };

    Connection.prototype.handleRemoteError = function(err) {
      return console.error("" + R + "ERROR" + X, 'Remote endpoint error', (err ? err.message : void 0));
    };

    Connection.prototype.initializeRemoteConnection = function() {
      if (Connection.verbose) {
        console.log('Remote endpoint connecting...', "" + this.remote_hostname + ":" + this.remote_port);
      }
      if (Connection.secure) {
        this.remote_endpoint = tls.connect(this.remote_port, this.remote_hostname, this.handleRemoteConnect);
      } else {
        this.remote_endpoint = net.connect(this.remote_port, this.remote_hostname, this.handleRemoteConnect);
        this.remote_endpoint.setKeepAlive(true);
      }
      this.remote_endpoint.setTimeout(0);
      this.remote_endpoint.setNoDelay();
      this.remote_endpoint.on('data', this.handleRemoteData);
      this.remote_endpoint.on('close', this.handleRemoteClose);
      return this.remote_endpoint.on('error', this.handleRemoteError);
    };

    function Connection(remote_port, options) {
      this.remote_port = remote_port;
      this.handleRemoteError = __bind(this.handleRemoteError, this);

      this.handleRemoteClose = __bind(this.handleRemoteClose, this);

      this.handleRemoteData = __bind(this.handleRemoteData, this);

      this.handleRemoteHandshake = __bind(this.handleRemoteHandshake, this);

      this.handleRemoteConnect = __bind(this.handleRemoteConnect, this);

      this.handleLocalError = __bind(this.handleLocalError, this);

      this.handleLocalClose = __bind(this.handleLocalClose, this);

      this.handleLocalData = __bind(this.handleLocalData, this);

      this.handleLocalConnect = __bind(this.handleLocalConnect, this);

      this.local_hostname = options.local_hostname, this.local_port = options.local_port, this.remote_hostname = options.remote_hostname, this.key = options.key;
      this.initializeLocalConnection();
      this.initializeRemoteConnection();
    }

    return Connection;

  })();

  remote_connection = new Connection(options.remote_port, options);

  remote_monitor_connection = new Connection(options.remote_monitor_port, options);

}).call(this);
